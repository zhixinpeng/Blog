## 为什么需要复杂度分析

正常情况下，我们通过统计、监控的方式，就可以得到算法执行时间和占用内存大小。为什么还要做复杂度分析呢？

* 测试结果非常依赖测试环境
* 测试结果受数据规模的影响很大

所以，我们需要一个不用具体的测试数据来测试，就可以粗略估计算法执行效率的方法

## 大 O 复杂度表示法

假设每行代码的执行时间都一样为 unit_time，通过这种思路分析到每段代码的执行时间，可以得到 **所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**。

我们用 T(n) = O(2n + 2) 和 T(n) = O(2n^2^ + 2n + 3) 来表示代码的执行时间，这就是大 O 时间复杂度表示法。

大 O 时间复杂度表示 **代码执行时间随数据规模增长的变化趋势**，所以也叫做 **渐进时间复杂度（asymptotic time complexity）**。

## 时间复杂度分析

* 只关注循环执行次数最多的一段代码
* 加法规则：总复杂度等于量级最大的那段代码的复杂度
* 乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

## 几种常见时间复杂度实例分析

![img](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)

以上复杂度量级几乎涵盖了以后所能接触到的所有代码的复杂度量级。粗略的分为两类：**多项式量级** 和 **非多项式量级**。其中，非多项式量级只有两个：O(2^n^) 和 O(n!)，我们把非多项式量级的算法问题叫做 NP（Non-Deterministic Polynomial 非确定多项式）问题。

当数据规模越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长，所以非多项式时间复杂度的算法是非常低效的算法。

- O(1)

  一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行代码，其时间复杂度也是 O(1)

- O(logn)、O(nlogn)

  ```java
  int i = 1;
  while(i <= n){
    i = i * 2;
  }
  ```

  第三行代码是循环执行次数最多的，所以，**只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度**。

  ![img](https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg)

  只要知道 x 值是多少，就知道这行代码的执行次数了，通过 2^x^ = n 求解得到 x = long~2~n，所以这段代码的时间复杂度就是 O(log~2~n)。

  现在是以 2 为底，若以 3 为底呢？实际上不管底为多少，我们都可以把对数据的时间复杂度都记为 O(logn)。

  这是为什么呢？

  我们知道对数之间可以互相转换，log~3~n 就等于 log~3~2 * log~2~n，所以 O(log~3~n) = O(C * log~2~n)，其中 C =log~3~2 是一个常量，基于我们前面的理论：**在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))**。因此我们统一表示未 O(logn)

- O(m + n)、O(m * n)

  有的时候，代码的复杂度 **由两个数据的规模** 来决定，我们无法评估两个数据规模谁更大，就用 m + n 或 m * n 来表示

## 空间复杂度分析

时间复杂度的全称是**渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系**。类比一下，空间复杂度就是**渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系**。

常见的空间复杂度有 O(1)、O(n)、O(n^2^)。

## 效率排名

![img](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)

越高阶复杂度的算法，执行效率越低，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2^)

## 最好、最坏时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

```java
// n 表示数组 array 的长度
int find(int[] array, int n, int x){
  int i = 0;
  int pos = -1;
  for(; i < n; ++i){
    if(array[i] == x) pos = i;
  }
  return pos;
}
```

在一个无序的数组中，查找变量 x 出现的位置，这段代码的复杂度是 O(n)。

我们在数组中查找数据，没必要每次都把整个数组都遍历一遍，只要中途遇到了就可以中断循环，因此改进一下。

```java
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

通过这段代码我们可以发现，最好情况在 i = 0 时就找到元素，这时的时间复杂度就是 O(1)，最坏情况在 i = n 时都还没有找到元素，这时的时间复杂度就是 O(n)。这就是我们要找的 **最好时间复杂度** 和 **最坏时间复杂度**。

## 平均情况时间复杂度

也叫 **加权平均时间复杂度** 或者 **期望时间复杂度**。

通过考虑每种情况出现时发生的概率，计算出来平均值，这个值是概率论中的 **加权平均值**，也叫 **期望值**

## 均摊时间复杂度

通过 **摊还分析法** 得到的时间复杂度，叫 **均摊时间复杂度**。

这个分析比较麻烦，暂时不做了解，加之其使用场景更加特殊，更加有限，暂不做深入了解。