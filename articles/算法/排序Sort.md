最经典、最常用的排序算法有：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。

## 如何分析一个排序算法

### 排序算法的执行效率

**1. 最好情况、最坏情况、平均情况时间复杂度**

对于要排序的数据，根据数据有序度的不同，对于排序的执行时间肯定有影响，我们要知道排序算法在不同数据下的性能表现。

**2. 时间复杂度的系数、常数、低阶**

时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候回忽略系数、常数、低阶。但实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以对同一阶时间复杂度的排序算法性能对比的时候，要考虑系数、常数、低阶。

**3. 比较次数和交换（或移动）次数**

基于比较的排序算法，会涉及到两个操作，一种是元素比较大小，一种是元素交换或移动。

### 排序算法的内存消耗

排序算法的内存消耗可以通过空间复杂度来衡量，排序也不例外。对于排序的空间复杂度，引入一个新概念，**原地排序（Sorted in place）**。原地排序算法，特指空间复杂度是 O(1) 的排序算法。

### 排序算法的稳定性

仅仅用执行效率和内存消耗来衡量排序算法是不够的。针对排序算法，还有一个重要的度量指标，**稳定性**。指的是，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后位置顺序不变。

如果前后顺序不变，叫**稳定的排序算法**，否则叫做**不稳定的排序算法**。

![img](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg)

## 冒泡排序（Bubble Sort）

冒泡排序只会操作相邻的两个数据。每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足则互换。**一次冒泡让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作**。

对冒泡排序进行优化。当某次冒泡操作没有产生数据交换时，则认为数据已完全有序，不用再继续执行后续的冒泡操作。

```java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n){
  if(n <= 1) return;
  for(int i = 0; i < n; ++i){
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for(int j = 0; j < n - i - 1; ++j){
      if(a[j] > a[j + 1]){
        // 交换
        int tmp = a[j];
        a[j] = a[j + 1];
        a[j + 1] = tmp;
        // 表示有数据交换
        flag = true;
      }
    }
    // 没有数据交换，提前退出
    if(!flag) break;
  }
}
```

- 冒泡排序是原地排序算法吗？

  冒泡过程只涉及到相邻数据的交换操作，只需要常量级的临时空间，空间复杂度为 O(1)，是原地排序算法

- 冒泡排序是稳定的排序算法吗？

  在冒泡排序中，只有交换才可以改变两个元素的前后顺序，而交换的前提条件就是相邻元素大小不相等，所以，当相邻元素相等时，是不会发生交换的，前后相等元素的顺序不会被改变，是稳定的排序算法

- 冒泡排序的时间复杂度是多少？

  最好情况下，是有序数据，只需要执行一次冒泡操作，最好情况时间复杂度为 O(n)。最坏情况时，是倒序数据，要进行 n 次冒泡操作，所以，最坏情况时间复杂度为 O(n^2^)。

  平均情况时间复杂度要通过有序度和逆序度来推导。平均情况下，需要 n * (n - 1) / 4 次交换操作，平均时间复杂度为 O(n^2^)。

![img](https://static001.geekbang.org/resource/image/88/34/8890cbf63ea80455ce82490a23361134.jpg)

## 插入排序（Insertion Sort）

对于一个有序的数组，我们往里面添加一个新的数据后，如果继续保持数据有序呢？很简单，只需要遍历数组，找到数据应该插入的位置将其插入即可。

这是一个动态排序的过程，即动态的往有序集合中添加数据，通过这种方法保持集合中的数据一直有序。

插入排序的核心思路如下：将数组中的数据分为两个区间，**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。取未排序区间的元素，在已排序区间中找到合适的插入位置插入，并保证已排序区间一直有序。重复这个过程，直到未排序区间中元素为空。

![img](https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg)

插入排序包含两种操作，一种是**元素的比较**，一种是**元素的移动**。

```java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n){
  if(n <= 1) return;
  for(int i = 1; i < n; ++i){
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for(; j >= 0; --j){
      if(a[j] > value){
        // 数据移动
        a[j + 1] = a[j]
      } else {
        break;
      }
    }
    // 插入数据
    a[j + 1] = value;
  }
}
```

- 插入排序是原地排序算法吗？

  从实现过程可以看出，不需要额外的存储空间，空间复杂度是 O(1)，是原地排序算法。

- 插入排序是稳定的排序算法吗？

  在插入排序中，我们可以选择将后面出现的相同元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。

- 插入排序的时间复杂度是多少？

  如果是有序数据，在这种情况下，我们**从尾到头遍历已经有序的数据**，这个时候的最好情况时间复杂度为 O(n) 。如果数组是倒序的，每次都需要在第一个位置插入新的数据，所以最坏情况时间复杂度为 O(n^2^)。

  在数组中插入一个数据的平均时间复杂度为 O(n)，对于插入排序来说，每次插入操作都需要插入一个数据，循环 n 次插入操作，所以平均时间复杂度为 O(n^2^)。

## 选择排序（Selection Sort）

选择排序的思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![img](https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg)

```java
// 选择排序，a 表示数组，n 表示数组大小
public void selectionSort(int[] a, int n){
  if(n <= 1) return;
  for(int i = 0; i < n; ++i){
    int minIndex = i;
    for(int j = i + 1; j < n; ++j){
      if(a[j] < a[minIndex]){
        minIndex = j;
      }
    }
    if(minIndex != i){
      int temp = a[i];
    	a[i] = min;
    	a[minIndex] = temp; 
    }
  }
}
```

选择排序的空间复杂度是 O(1)，是一种原地排序算法。

选择排序的最好情况时间复杂度、最坏情况时间复杂度和平均情况复杂度都为 O(n^2^)。

选择排序是一种不稳定的排序算法。因为未排序区间的最小值元素都会和前面的元素交换位置，会破坏稳定性。

因此，相对于冒泡排序和插入排序，选择排序就稍显逊色了。

## 归并排序（Merge Sort）

![img](https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg)

归并排序采取分治思想，分而治之，最后合并。

```java
// 递推公式
merge_sort(p...r) = merge(merge_sort(p...q) + merge_sort(q + 1...r));

// 终止条件
p >= r;
```

```java
// 分解
public void merge_sort(int[] a, int p, int r){
  if(p >= r) return;
  int q = p + (r - p) / 2;
  merge_sort(a, p, q);
  merge_sort(a, q + 1, r);
  merge(a, p, q, r);
}

// 合并
public void merge(int[] a, int p, int q, int r){
  int i = p;
  int j = q + 1;
  int k = 0;
  int[] tmp = new int[r - p + 1];
  
  while(i <= q && j <= r){
    if(a[i] <= a[j]){
      tmp[k++] = a[i++];
    }else{
      tmp[k++] = a[j++];
    }
  }
  
  // 判断左右两个数组哪个还有剩余元素
  int start = i == q ? j : i;
  int end = i == q ? r : q;
  
  // 将剩余数据拷贝进 tmp 数组
  while(start <= end){
    tmp[k++] = a[start++];
  }
  
  // 将 tmp 数组拷贝回原数组的 p 到 r 位置
  for(i = 0; i < r - p; ++i){
    a[p + i] = tmp[i];
  }
}
```

- 归并排序是稳定的排序算法吗？

  稳定不稳定关键看 merge 函数，让前段数组 A[p…q] 中的元素先放入数组，就可以保证原有的先后顺序不变。所以，归并排序是一个稳定的排序算法。

- 归并排序的时间复杂度是多少？

  归并排序的时间复杂度与原始数组的有序度是无关的，所以无论最好情况、最坏情况、平均情况下的时间复杂度都是 O(nlogn)。

- 归并排序是原地排序算法吗？

  归并排序的时间复杂度在任何情况下都是 O(nlogn)，非常优秀。但是它没有快排那样应用广泛，这就是因为归并排序并不是一个原地排序算法。这是因为在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。

  在任意时刻，CPU 只会有一个函数在执行，也就是只会开辟一个临时的内存空间在使用。临时空间最大也不会超过 n 个数据的大小。所以空间复杂度是 O(n)。

## 快速排序（Quick Sort）

快速排序，我们习惯简称为“快排”。快排利用的也是分治思想。乍看起来，有点像归并排序，但思路完全不一样。

快排的思想是：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为分区点（pivot）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q - 1 之间都是小于 pivot 的，中间是 pivot，后面的 q + 1 到 r 之间是大于 pivot 的。

```java
// 递推公式
quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1...r);

// 终止条件
p >= r;
```

```java
public void quick_sort(int[] a, int p, int r){
  if(p >= r) return;
  // 获取分区点
  int q = partition(a, p, r);
  quick_sort(a, p, q - 1);
  quick_sort(a, q + 1, r);
}

public int partition(int[] a, int p, int r){
  int pivot = a[r];
  int i = p;
  
  for(int j = p; j < r; ++j){
    if(a[j] < pivot){
      if(i == j){
        ++i;
      }else{
        int tmp = a[i];
        a[i++] = a[j];
        a[j] = tmp;
      }
    }
  }
  
  int tmp = a[i];
  a[i] = a[r];
  a[r] = a[tmp];
  
  return i;
}
```

归并排序有一个 merge 合并函数，这里有一个 partition 分区函数。partition 分区函数就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r] 分区，返回 pivot 的下标。

如果不考虑空间消耗的话，parition 分区函数可以写的非常简单。申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中的数据顺序拷贝到 A[p…r]。这样做的话，partition 函数就需要很多额外的内存空间，快速排序就不是原地排序算法了。

现在原地排序的处理是：

这里类似选择排序。通过游标 i 把 A[p…r-1]分成两部分。A[p…i-1]的元素都是小于 pivot 的，叫已处理区间，A[i…r-1]的是未处理区间。每次都从未处理区间中取出一个元素与 pivot 对比，如果小于 pivot 的，将其加入到已处理区间的尾部，也就是 A[i] 的位置。

数组的插入操作需要搬移数据，是非常耗时的。通过交换的处理技巧，可以在事件复杂度为 O(1) 内完成交换操作。

![img](https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg)

归并排序和快速排序都用了分治思想，递推公式和递归代码也非常相似，那它们区别在哪里？

![img](https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg)

可以发现，归并排序的处理是**由下到上**的，先处理子问题再合并。二快排正好相反，处理过程是**由上到下的**，先分区，再处理子问题。

快排是原地、不稳定的排序算法，快排在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n^2^)。

```java
// 寻找数组中的第 K 大元素
public void searchK(int[] a, int k){
  if(a == null || a.length < k) return -1;
  
  int n = a.length;
  int p = partition(a, 0, n - 1);
  while(p + 1 != k){
    if(p + 1 > k){
      // 第 k 大元素在 p + 1 的左边
      p = partition(a, 0, p - 1);
    }else{
      // 第 k 大元素在 p + 1 的右边
      p = partition(a, p + 1, n - 1);
    }
  }
  
  return a[p];
}

private int partition(int[] a, int p, int r){
  int pivot = a[r];
  int i = p;
  for(int j = p; j < r; ++j){
    if(a[j] >= pivot){
      swap(a, i, j);
      i++;
    }
  }
  swap(a, i, r);
  return i;
}

private void swap(int[] a, int p, int r){
  if(p == r) return;
  int tmp = a[p];
  a[p] = a[r];
  a[r] = tmp;
}
```

以上介绍的排序算法时间复杂度都是比较高的，现在介绍三种时间复杂度是 O(n) 的排序算法：桶排序、计数排序、基数排序。这类排序算法也叫**线性排序（Linear Sort）**。这类排序算法分析起来很简单，但是对要排序的数据要求很苛刻。

## 桶排序（Bucket Sort）

核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排序完成之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。

![img](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg)

- 为什么桶排序的时间复杂度是 O(n) 呢？

  如果要排序的数据有 n 个，均匀分到 m 个桶内，每个桶有 k = n / m 个元素。每个桶内使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk) = O(n * log(n / m))。当桶的个数 m 接近数据个数 n 时，log(n / m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。

- 桶排序这么优秀，是不是可以替代快速排序和归并排序等算法？

  要排序的数据需要很容易就能划分成 m 个桶，并且桶和桶之间有着天然的大小顺序。

  其次，数据再各个桶之间的分布式比较均匀的。极端情况下，都放到一个桶里，就退化为 O(nlogn) 算法了。

  桶排序比较适合用在外部排序中。

```java
// a 需排序数组，size 桶容量
public void bucketSort(int[] a, int size){
  if(a.length < 2) return;
  // 数组初始最小值和最大值
  int min = a[0];
  int max = a[1];
  // 找出数组中的最小值和最大值
  for(int i = 0; i < a.length; ++i){
    if(a[i] < min){
      min = a[i];
    }else if(a[i] > max){
      max = a[i];
    }
  }
  // 桶数组
  int count = (max - min) / size + 1;
  int[][] buckets = new int[count][size];
  int[] indexArr = new int[count];
 	// 将数组中值分配到各个桶里
  for(int i = 0; i < a.length; ++i){
    int bucketIndex = (a[i] - min) / size;
    buckets[bucketIndex][indexArr[bucketIndex]++] =a[i];
  }
  // 对每个桶进行排序
  int k = 0;
  for(int i = 0; i < buckets.length; ++i){
    if(indexArr[i] == 0) return;
    // 使用快速排序对每个桶进行排序
    quickSort(buckets[i], 0, indexArr[i] - 1);
    for(int j = 0; j < indexArr[i]; j++){
      arr[k++] = buckets[i][j];
    }
  }
}
```

## 计数排序（Counting Sort）

**计数排序是桶排序的一种特殊情况**。当要排序的数据所处的范围并大大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据都是相同的，省掉了桶内排序的时间。

比如高考查分系统，满分是 900 分，根据这个分数划分为 901 个桶，如果全省有 50 万考生，那这 50 万个数据就会被分配到这 900 个桶中。因为只涉及到扫描遍历操作，所以时间复杂度是 O(n)。

从后往前扫描数组 A。当扫描到 3 时，可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 的第 7 个元素。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下 6 个了，所以相应的 C[3] 要减 1，变成 6。

![img](https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg)

```java
// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n){
  if(n <= 1) return;
  // 查找数组中数据的范围
  int max = a[0];
  for(int i = 1; i < n; ++i){
    if(a[i] > max){
      max = a[i];
    }
  }
  
  // 申请一个计数数组 c，下标大小 [0, max]
  int[] c = new int[max + 1];
  for(int i = 0; i <= max; ++i){
    c[i] = 0;
  }
  
  // 计算每个元素的个数，放入 c 中
  for(int i = 0; i < n; ++i){
    c[a[i]]++;
  }
  
  // 依次累计
  for(int i = 1; i <= max; ++i){
    c[i] = c[i - 1] + c[i];
  }
  
  // 临时数组 r 存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤
  for(int i = n -1; i >= 0; --i){
    int index = c[a[i]] - 1;
    r[index] = a[i];
    c[a[i]]--;
  }
  // 将结果拷贝给 a 数组
  for(int i = 0; i < n; ++i){
    a[i] = r[i];
  }
}
```

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且计数排序只能给非负整数排序，如果要排序的数据时其他类型的，要将其在不改变相对大小的情况下，转化为非负整数**

## 基数排序（Radix Sort）

假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序。

这个问题有个规律：如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面几位就不用看了。

借助稳定排序算法，先按照最后一位来排序手机号码，然后再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序，经过第 11 次排序之后，手机号码就都有序了。

根据每一位来排序，可以用桶排序或者计数排序，时间复杂度可以做到 O(n)。要排序的数据有 k 位，就需要 k 次桶排序或者计数排序，总得时间复杂度是 O(k * n)。当 k 不大时，基数排序的时间复杂度就是 O(n)。

**基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基础排序的时间复杂度就无法做到 O(n) 了**

## 如何设计通用的、高性能的排序函数

![img](https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg)

快速排序比较适合用来实现排序函数，但是，快速排序在最坏情况下的时间复杂度为O(n^2^)，如何解决这个“复杂度恶化”的问题呢？

实际上，**这种 O(n^2^)时间复杂度出现的主要原因是分区点选择的不够合理**。

最理想的分区点是：**被分区点分开的两个分区中，数据的数量差不多。**

为了尽可能的让每次分区都比较平均，以下有两个比较常用、简单的分区算法：

- **三数取中法**

  从区间的首、尾、中，分别取出一个数，对比大小，取这 3 个数的中间值作为分区点。如果排序的数组比较大，“三数”可能就不够了，就需要“五数”或者“十数”取中。

- **随机法**

  每次从要排序的区间中，随机选择一个元素作为分区点。从概率的角度看，不大可能出现每次分区点都是最差情况，所以平均情况下，时间复杂度退化为最糟糕的 O(n^2^)的情况，出现的可能性不大。

### 举例分析排序函数

以 Glibc 中的 qsort 排序函数为例。

**qsort 会优先使用归并排序来排序输入数据**，因为归并排序的空间复杂度为 O(n)，对于小数据的排序，问题不大。

如果数据量太大，使用归并排序就不合适了，所以，**要排序的数据量比较大的时候，qsort 会改用为用快速排序算法来排序**。

那 qsort 是如何选择快速排序算法的分区点呢？其实使用的就是”三数取中法“。

实际上，qsort 不仅用到了归并排序和快速排序，还是用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort 就退化为插入排序，不再使用递归来做快速排序。因为，**在小规模数据面前，O(n^2^) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长**。

最后，在插入排序的算法中使用哨兵来简化代码，提到效率。虽然哨兵可能只是少做了一次判断，但毕竟排序函数是非常常用、非常基础的函数，性能优化要做到极致。

