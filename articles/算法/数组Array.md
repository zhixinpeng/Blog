**数组是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**

* **线性表（Linear List）**。就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。

  ![img](https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg)

  ![img](https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg)

* **连续的内存空间和相同类型的数据**。正是因为这两个限制，它才有一个堪称“杀手锏”的特性：随机访问。有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如插入、删除数据，为了保证连续性，就需要做大量的数据搬移工作。

  ![img](https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg)

## 低效的插入、删除操作

- **插入操作**

  假如数组的长度为 n，如果我们需要将一个数据插入到数组的第 k 个位置。为了把第 k 个位置腾出来，我们需要将 k ~ n 这部分的元素都顺序的往后挪一位。

  如果在数组的末尾插入元素，最好时间复杂度为 O(1)，如果在数组的开头插入元素，最坏时间复杂度为 O(n)。因为我们在每个位置插入元素的概率都一样，所以平均时间复杂度为 (1+2+…+n)/n = O(n)。

  如果数组是有序的，那么我们必须按照上面的方式插入数据。但是，如果数组中存储的数据没有任何规律，数组只是当做一个数据集合的情况下，为了避免大规模的数据迁移，我们有一个简单的办法，就是直接把第 k 位元素搬移到数组元素的最后，把最新的元素直接放入到第 k 个位置。

  利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。

  这个处理思想在快排中会应用到。

- **删除操作**

  和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)，如果删除开头的数据，则最坏情况时间复杂度为 O(n)，平均情况时间复杂度为 O(n)。

  实际上，在某些特殊场景下，我们并不一定要追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多。

  ![img](https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)

  依次删除 a/b/c 三个元素，为了避免数据被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再出发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

  这就是 JVM 标记清除垃圾回收算法的核心思想。

## 警惕数组越界问题

数组越界会导致一些莫名其妙的逻辑错误，debug 的难度非常大。而且，很多计算机病毒也正是利用到代码中的数组越界可以访问非法地址的漏洞，来攻击系统，所以写代码的时候一定要警惕数组越界。

## 容器能否完全替代数组

针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList。

ArrayList 最大的优势就是 **可以将很多数组操作的细节封装起来**，另外一个优势就是 **支持动态扩容**。

如果事先能够确定需要存储的数据大小，最好**在创建 ArrayList 的时候事先指定数据大小**。

那什么时候使用数组，什么时候使用容器呢？以下是几点经验

- ArrayList 无法存储基本类型，比如 int、long，需要封装为 Interger、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，若特别关注性能，可选用数组
- 如果数据大小事先已知，并且对数据操作非常简单，用不到大部分 ArrayList 提供的方法，可选用数组
- 表示多维数组时，Object[][] array 比 ArrayList<ArrayList<Object>>array 更加直观

其实对于业务开发，直接使用容器就够了，除非特别关注性能的场景，可以选用数组。

## 为什么数组下标要从 0 开始编号，而不是从 1 开始呢

从 0 开始计数，可以直接通过下面的公式计算得到元素的内存地址，而不用再执行一次减 1 操作，比较直观与快捷。

```java
a[k]_address = base_address + k * type_size
```

另外，更多的是历史原因。C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言。