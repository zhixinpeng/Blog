贪心算法、分治算法、回溯算法、动态规划是四种算法思想，用于指导我们设计具体的算法和编码。

贪心算法的经典应用有：

- 霍夫曼编码Huffman Coding
- Prim、Kruskal最小生成树算法
- Dijkstra单源最短路径算法

## 思路解析

1. 分糖果

   我们有m个糖果和n个孩子，但是糖果少孩子多(m<n)，m个糖果的大小分别是s1、s2、s3...，n个孩子对糖果的需求是g1、g2、g3...，如何分配糖果能尽量满足最多梳理的孩子？

   思路：每次从剩下的孩子中找到对糖果需求最小的，然后在剩下糖果中找到能满足他的最小的糖果。

2. 钱币找零

   我们有1元、2元、5元、10元、20元、50元、100元面额的纸币，如何用最少张数的纸币来支付K元？

   思路：先用面额最大的来支付，不够再用更小一点面值的（贪心算法在这个问题上有所缺陷，用动态规划会更加合适）

3. 区间覆盖

   假设我们有n个区间，区间的起始端点和结束端点分别是[l1,r1]，[l2,r2]，[l3,r3]...，从这n个区间中选出一部分区间两两不相交，最多可以选出多少个区间？

   思路：假设n个区间的最左端点是lmin，最右端点是rmax。这个问题就相当于选择几个不相交的区间，从左到右将[lmin,rmax]覆盖上，我们按照起始端点从小到大的顺序对这n个区间排序，每次选择的时候，左端点跟前面已覆盖的区间不重合，右端点选尽量小的，让剩下的未覆盖区间尽可能大，就可以放置更多的区间。

## 霍夫曼编码

如何利用贪心算法来实现霍夫曼编码来实现对数据压缩编码，有效节省数据存储空间的。

一个1000字符的文件，每个字符1个byte(1byte=8bits)，共需要用8000bits。我们通过统计发现，文件只包含了6种不同的字符，用三个二进制就可以表示8中不同的字符，那存储这文件只需要3000bits就够了。

**除了考察有多少不同字符，还要考察每个字符的出现频率，根据频率的不同，选择不同长度的编码**。把出现频率多的字符，用稍微短一点的编码，出现频率少的字符，用稍微长一些的编码，编码不等长，且不会出现某个编码是另一个编码前缀的情况。

![img](https://static001.geekbang.org/resource/image/83/45/83921e609c8a4dc81ca5b90c8b4cd745.jpg)

通过这种方式，2100bits就可以了。那如果根据出现频率的不同，给不同字符不同长度的编码呢？

![img](https://static001.geekbang.org/resource/image/7b/7a/7b6a08e7df45eac66820b959c64f877a.jpg)

从队列中取出频率最小的两个节点A、B，新建一个节点C频率设置为他们的和，作为A、B节点的父节点，C节点放回队列，重复过程，直到队列中没有数据。

![img](https://static001.geekbang.org/resource/image/cc/ed/ccf15d048be005924a409574dce143ed.jpg)

然后标记左节点为0，右节点为1，那么从根节点到页节点的对应字符就是霍夫曼编码。

## 示例

1. 在一个非负整数 a 中，希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？

   解：借助栈结构，首高位入栈，高位和次位进行比较，次位较大，次位入栈，次位较小，栈顶出栈。继续放下一位，重复这一操作。边界情况：如果k为0了还有元素在栈外，将剩余元素入栈；如果元素已全部入栈，k还没到0，则从栈顶移除剩余的数目即可。借助栈的思想比使用循环遍历的效率要更高

2. n个人等待服务，窗口只有一个，每个人被服务的时间不同，如果安排服务顺序，才能让这n个人的等待时间最短？

   解：让需要服务时间短的人先来