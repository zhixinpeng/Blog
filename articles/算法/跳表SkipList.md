在二分查找算法中，由于需要依赖数组的随机访问特性，所以不得不选择数组这种数据结构。那如果数据存储在链表中，如何让其支持类似“二分”的查找算法呢？

答案就是经过改造后的数据结构**跳表（SkipList）**。

## 什么是跳表

对于单链表来说，要查找一个数组，只能从头到尾遍历链接，时间复杂度很高为 O(n)。

如何提高查找效率呢？

每两个结点提取一个结点到上一级，我们把抽出来的那一层叫做**索引**或**索引层**。索引的 down 指针指向下一级结点。

如果要查找某个结点，比如 16，可以先遍历索引层，当遍历到索引层中值为 13 且下一个结点是 17 时，我们就知道了要查找的 16 结点就在这两个结点之间。然后我们通过 13 的 down 指针下降到下一层继续遍历就找到了 16 结点。这样原来需要遍历 10 个结点，现在只需要遍历 7 个结点。

从以上例子中可以看出，**加一层索引层之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率变高了**。

![img](https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg)

利用上面这种思想，我们可以在第一层索引层之上再每个结点抽出一个结点到第二次索引层。这样查找一个结点需要遍历的结点又少了。当链表的长度比较大时，在构建索引之后，查找效率的提升会非常明显。

![img](https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg)

**这种链表加多级索引的结构，就是跳表**。

## 用跳表查询有多快

建立跳表的过程和二分算法的思想很类似，**在跳表中查询任意数据的时间复杂度是 O(logn)**。这个查找的时间复杂度和二分查找是一样的。不过天下没有免费的午餐，这种查询效率的提升，前提是建立了很多索引。这是一种**空间换时间**的设计思路。

## 跳表是不是很浪费内存

每两个结点提取一个索引结点的方式，需要的空间复杂度是 O(n)。我们需要额外再用接近 n 个结点的存储空间。

如果改成三个结点提取一个索引结点，需要的空间复杂度还是 O(n)。但比上面的索引构建方法，减少了一半的索引结点存储空间。

实际上，在软件开发中，不必太在意额外占用的额外空间。因为实际开发中，原始链表中可能存储的是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以那些索引占用的额外空间完全可以省略。

## 高效的动态插入和删除

跳表这个动态数据结构，不仅支持高效的查找操作，还支持动态的插入、删除操作，而且插入、删除的时间复杂度也是 O(logn)。

在原来的单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是 O(1)。但是我们需要遍历每个结点来找到要插入的位置，这个查找操作就比较耗时。

对于跳表来说，查找一个结点的时间复杂度是 O(logn)，所以插入一个结点的时间复杂度也是 O(logn)。

![img](https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg)

在删除时，除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要获取到删除节点的前驱结点，然后通过指针操作删除。所以在跳表中查找要删除的节点的时候，一定要获取前驱结点。如使用的是双向链表，就不用考虑这个问题了。

## 跳表索引动态更新

在往跳表中插入数据时，如果不更新索引，就会出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表就会退化成单链表。

跳表是通过随机函数来维护跳表的平衡性的。

当我们往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引中。如果选择加入哪层索引呢？

通过随机函数，来决定。比如随机函数生成了 K，就吧结点添加到第一级到 K 级这 K 级索引中。

