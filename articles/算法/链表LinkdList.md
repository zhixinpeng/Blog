链表这种数据结构有一个经典的应用场景，那就是 LRU 缓存淘汰算法。

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等。

缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些应该保留？这就需要缓存淘汰策略来决定。

常见的策略有三种：

- 先进先出策略 FIFO（First in, First out）
- 最少使用策略 LFU（Least Frequently Used）
- 最近最少使用策略 LRU（Least Recently Used）

## 链表结构

数组需要一块**连续的内存空间**来存储，对内存的要求比较高。如果我们申请 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便剩余的总可用内存空间大于 100MB，仍然会申请失败。

而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组**零散的内存块**串联起来使用。

![img](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

最常用的链表结构有：单链表、双向链表和循环链表。

- **单链表**

  链表通过指针将一组零散的内存块串联在一起。我们把内存块称为链表的**“结点“**，结点除了存储数据外，还要记录下一个结点的地址，我们把这个记录指针称为**后继指针next**。

  ![img](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)

  以上单链表的结构图中，有两个特殊的节点，第一个结点称为**头结点**，最后一个几点称为**尾结点**。头结点记录链表的基地址，尾结点指向**空地址 NULL**。

  在数组中进行插入、删除操作时，由于要保证内存的连续性，需要做大量数据搬移，时间复杂度为 O(n)，而在链表中插入或删除数据时，只需要考虑相邻结点的指针改变，时间复杂度为 O(1)。

  有利有弊，当想查找第 k 个元素时，链表无法像数组一样根据首地址和下标快速定位，只能一个节点一个节点遍历，需要 O(n) 的时间复杂度。

- **循环链表**

  **循环链表是一种特殊的单链表**。它与单链表唯一的区别就在尾结点。单链表的尾结点指向空地址，表示这是最后的节点。而循环链表的尾结点指针是指向链表的头结点。

  ![img](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)

- **双向链表**

  单链表只有一个后继指针 next 指向后面的节点。而双向链表，它有两个方向，每个节点除了有一个后继指针 next 指向后面的节点，还有一个前驱指针 prev 指向前面的结点。

  ![img](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)

  从图中可以看出，双向链表需要额外的两个空间来存储前驱结点和后继结点，比较耗费空间。

  从结构上看，双向链表支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，在某些情况下，双向链表比单向链表的插入、删除操作要更简单、高效。

  先看删除操作，分为两种情况：

  - 删除结点中”值等于某个给定值“的结点
  - 删除给定指针指向的结点

  对于第一种情况，单选链表和双向链表都需要从头结点开始遍历查找，然后进行删除，这里没有什么差异，时间复杂度均为 O(n)。

  对于第二种情况，删除结点需要知道前驱结点，而单向链表要知道前驱结点只能从头结点开始遍历，直到 p->next=q，说明 p 是 q 的前驱结点。单向链表时间复杂度 O(n)，双向链表时间复杂度 O(1)。

  如果我们希望在一个指定结点前面插入一个结点，双向链表比单向链表也有很大的优势。双向链表时间复杂度为 O(1)，单向链表时间复杂为 O(n)。

  除了插入、删除，对于一个有序链表，双向链表的查询效率也要比单向链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定往前找还是往后找，所以平均只需查找一半的数据。

- **双向循环链表**

  ![img](https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg)

## 链表与数组性能大比拼

![img](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)

## 如何基于链表实现 LRU 缓存淘汰算法

维护一个有序单向链表，越靠近尾部的结点是越早之前访问的。当有新数据被访问时，从头结点开始遍历链表。

- 如果此数据已经被缓存在链表中，遍历得到这个数据对应的结点，将其从原来的位置删除，再插入到链表头部
- 如果此数据没有在缓存链表中，分为两种情况：
  - 如果此时缓存未满，则将此结点直接插入到链表的头部
  - 如果此时缓存已满，则将链表尾结点删除，将新的数据结点插入到链表的头部

基于这种思路实现的缓存访问时间复杂度为 O(n)。

实际上，我们可以继续优化这个实现思路，比如引入 **散列表（Hash Table）**来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。

除了基于链表的 LRU 算法实现，还可以基于数组实现。

## 如何轻松写出链表代码

- **理解指针或引用的含义**

  将某个变量赋值给指针，实际上是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

- **警惕指针丢失和内存泄露**

  ![img](https://static001.geekbang.org/resource/image/05/6e/05a4a3b57502968930d517c934347c6e.jpg)

  以上图为例，插入一个结点 x，如果使用如下代码就会发生内存泄露

  ```java
  p->next = x;  // 将p的next指针指向x结点；
  x->next = p->next;  // 将x的结点的next指针指向b结点；
  ```

  p -> next 指针指向 x 后，x -> next 指向了 x，相当于自己指向自己，链表断裂。将上述两行代码颠倒执行就可正常使用。

  所以，**插入结点时，要注意操作的顺序**，**删除结点时，也要记得手动释放内存空间**。

- **利用哨兵简化实现难度**

  针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

  如果我们引入哨兵结点，在任何时候，不管链表是不是为空，head 指针都会一直指向这个哨兵结点，这种有哨兵结点的链表叫**带头链表**。

  这样插入第一个结点和其他结点、删除最后一个结点和其他结点，都可以统一为相同的代码实现逻辑了。

- **重点留意边界条件处理**

  软件开发中，代码在一些边界或者异常情况下，最容易产生 BUG。

  - 如果链表为空时，代码能否正常工作
  - 如果链表只包含一个结点时，代码能否正常工作
  - 如果链表只包含两个结点时，代码能否正常工作
  - 代码逻辑在处理头结点和尾结点的时候，代码能否正常工作

- **举例画图，辅助思考**

  举例法和作图法可以释放脑容量，留更多给逻辑思考

- **多写多练，没有捷径**

  以下 5 个常见的链表操作要熟悉

  - 单链表反转
  - 链表中环的检测
  - 两个有序链表合并
  - 删除链表倒数第 n 个结点
  - 求链表的中间节点